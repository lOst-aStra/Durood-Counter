# Story 1.3: Persist counts with DataStore

## Status
Done

## Story
As a user,
I want my count to persist across restarts,
so that I don’t lose progress until I reset intentionally. [Source: docs/prd/epic-1-foundation-core-counter.md]

## Acceptance Criteria
1. Count restored on app launch after process death/restart [Source: docs/prd/epic-1-foundation-core-counter.md]
2. DataStore used for persistence with atomic writes [Source: docs/prd/epic-1-foundation-core-counter.md]
3. No network/analytics dependencies introduced [Source: docs/prd/epic-1-foundation-core-counter.md]

## Non-Goals
- Analytics, crash reporting, or remote sync.
- Complex migrations; preferences keys only for this story.
- Haptic feedback (covered by Story 1.4).

## Tasks / Subtasks
- [x] Create Data layer scaffolding (AC: 2)
  - [x] `data/datastore/CounterLocalDataSource.kt`: Implement Preferences DataStore with atomic `updateData` writes. [Source: docs/architecture-shards/data-model-and-persistence.md]
  - [x] Preferences keys: `current_count:Int`, `completed_sets:Int`, `last_updated_epoch_ms:Long` (optional). [Source: docs/architecture-shards/data-model-and-persistence.md]
  - [x] DataStore file name: `counter_prefs.pb` (arbitrary name, still Preferences). [Source: docs/architecture-shards/data-model-and-persistence.md]
  - [x] Expose a Flow mapping preferences → DTO used by repository.
- [x] Implement repository (AC: 1, 2)
  - [x] `data/CounterRepository.kt`: public contract with suspend functions to mutate state and a `Flow` for observing values. [Source: docs/architecture-shards/modules-and-packages.md]
  - [x] Ensure increments/decrements perform atomic updates and handle 0..99 rollover and `completed_sets` updates. [Source: docs/architecture-shards/business-logic.md]
- [x] Wire DI (manual) (AC: 1)
  - [x] `di/AppModule.kt`: provide DataStore instance, data source, and repository. [Source: docs/architecture-shards/modules-and-packages.md]
- [x] ViewModel integration (AC: 1)
  - [x] `presentation/CounterViewModel.kt`: collect repository `Flow` in `init` into `state: StateFlow<CounterState>`. [Source: docs/architecture-shards/viewmodel-and-state.md]
  - [x] Implement intents `onIncrement()`, `onDecrement()`, etc. to call repository.
  - [x] Ensure that on cold start after process death, state initializes from repository Flow without flicker.
- [x] UI remains unchanged (from Story 1.2) but reflects persisted state (AC: 1).
- [x] Ensure no network or analytics libraries are added (AC: 3).
- [x] Tests (see Testing section) verifying persistence and atomicity.

## Dev Notes

### Data Model & Persistence
- Use Preferences DataStore with keys:
  - `current_count: Int` – 0..99 (rolling set window)
  - `completed_sets: Int` – number of full 100s completed
  - `last_updated_epoch_ms: Long` – optional; for future UX [Source: docs/architecture-shards/data-model-and-persistence.md]
- Reads: a single `Flow` mapped to a small DTO, then to `CounterState` in repository/ViewModel.
- Writes: `updateData { prefs -> ... }` for atomicity. DataStore handles threading internally. [Source: docs/architecture-shards/data-model-and-persistence.md]

### Packages & Files
- `com.lostastra.duroodcounter.data`
  - `CounterRepository.kt`
  - `datastore/CounterLocalDataSource.kt`
- `com.lostastra.duroodcounter.presentation`
  - `CounterViewModel.kt` (consume repository Flow into `StateFlow<CounterState>`)
- `com.lostastra.duroodcounter.di`
  - `AppModule.kt` (manual providers)
[Source: docs/architecture-shards/modules-and-packages.md, docs/architecture-shards/viewmodel-and-state.md]

### Build & Dependencies
- DataStore dependency is already present: `implementation("androidx.datastore:datastore-preferences:1.1.1")`. [Source: app/build.gradle.kts]
- No additional libraries required for this story.

### Performance & UX
- Keep state updates minimal; repository performs atomic updates to avoid race conditions.
- Avoid work on main thread beyond collecting Flows into UI state. [Source: docs/architecture-shards/performance.md]

## Testing
- Unit tests (JVM):
  - Repository logic for increment/decrement and rollover to update `completed_sets` correctly.
  - Atomic updates: concurrent increments simulated using runTest and ensure final state matches expected.
- Instrumented tests (Android):
  - Verify that after writing a value, killing and relaunching process restores the same value to UI (or at least repository Flow).
- UI tests (Compose):
  - Optional: Start screen, simulate +1 and process recreation via saved state handle or test rule, assert restored value.
[Source: docs/architecture-shards/testing-strategy.md]

## Change Log
| Date       | Version | Description                                   | Author |
|------------|---------|-----------------------------------------------|--------|
| 2025-09-15 | 1.0     | Implementation completed, ready for review    | Cascade|
| 2025-09-14 | 0.1     | Initial draft from PRD + Architecture shards  | SM     |

## Dev Agent Record
- Agent Model Used: Cascade
- Source References:
  - `docs/prd/epic-1-foundation-core-counter.md` (Epic 1, Story 1.3)
  - `docs/architecture-shards/data-model-and-persistence.md`
  - `docs/architecture-shards/modules-and-packages.md`
  - `docs/architecture-shards/viewmodel-and-state.md`
  - `app/build.gradle.kts` (DataStore dependency present)
